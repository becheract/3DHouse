/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 black_arms.glb --transform 
Files: black_arms.glb [1.08MB] > /Users/bechera/Documents/3DHouse/public/Arms/black_arms-transformed.glb [565.6KB] (48%)
*/
import { useRef, useEffect, useMemo, useState } from "react";
import { useGraph} from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";

// Debounce utility function for cooldowns
const debounce = (func: Function, delay: number) => {
  let timer: NodeJS.Timeout;
  return (...args: any[]) => {
    clearTimeout(timer);
    timer = setTimeout(() => func(...args), delay);
  };
};

export default function Model(props: JSX.IntrinsicElements["group"]) {
  const group = useRef<THREE.Group>(null);
  const { scene, animations } = useGLTF('Arms/black_arms-transformed.glb')
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const [firstLoad, setFirstLoad] = useState(true);
  const { actions,  mixer } = useAnimations(animations, group);
  const [combat, setCombat] = useState(false);
  const [combatCooldown, setCombatCooldown] = useState(false);
  const [actionFeedback] = useState<string | null>(null);

    
    // Handle first load animation
    useEffect(() => {
      if (actions.Relax_hands_idle_start !== null && firstLoad && actions.Relax_hands_idle_loop !== null) {
        actions.Relax_hands_idle_start.play();
        actions.Relax_hands_idle_start.repetitions = 1;
        mixer.stopAllAction();
        actions.Relax_hands_idle_start.reset().play();
        setFirstLoad(false);
      }
    }, [actions, firstLoad, mixer]);
  
    // Play idle animation
    const playIdle = () => {
      mixer.stopAllAction();
      if (actions.Relax_hands_idle_loop) {
        actions.Relax_hands_idle_loop.play();
        setCombatCooldown(false);
      }
    };
  
    // Listen for animation finish and transition to idle
    useEffect(() => {
      mixer.addEventListener('finished', playIdle);
      return () => {
        mixer.removeEventListener('finished', playIdle);
      };
    }, [mixer]);
  
    // Handle keyboard input (e.g., "f" for action)
    useEffect(() => {
      const keyDownListener = (e: KeyboardEvent) => {
        if (e.key === "f" || e.key === "F") {
          if (actions.Collect_something && actions.Relax_hands_idle_loop) {
            actions.Collect_something.play();
            actions.Collect_something.repetitions = 1;
            mixer.stopAllAction();
            actions.Collect_something.crossFadeTo(actions.Relax_hands_idle_loop, 0.5, true);
            actions.Collect_something.reset().play();
          }
        }
      };
  
      document.addEventListener("keydown", keyDownListener);
      return () => {
        document.removeEventListener("keydown", keyDownListener);
      };
    }, [actions, mixer]);
  
    // Handle mouse click for combat actions
    useEffect(() => {
      const mouseListener = debounce((e: MouseEvent) => {
        const random = Math.random();
        if (e.button === 0) { // 0 is for left mouse button
          setCombat(true);
          if (random < 0.5) {
            if (actions.Combat_punch_right && actions.Relax_hands_idle_loop) {
              actions.Combat_punch_right.play();
              actions.Combat_punch_right.repetitions = 1;
              mixer.stopAllAction();
              actions.Combat_punch_right.crossFadeTo(actions.Relax_hands_idle_loop, 0.5, true);
              actions.Combat_punch_right.reset().play();
            }
          } else {
            if (actions.Combat_punch_left && actions.Relax_hands_idle_loop) {
              actions.Combat_punch_left.play();
              actions.Combat_punch_left.repetitions = 1;
              mixer.stopAllAction();
              actions.Combat_punch_left.crossFadeTo(actions.Relax_hands_idle_loop, 0.5, true);
              actions.Combat_punch_left.reset().play();
            }
          }
        }
      }, 50);
  
      document.addEventListener("click", mouseListener);
      return () => {
        document.removeEventListener("click", mouseListener);
      };
    }, [actions, mixer]);
  
    // Combat idle logic and cooldown
    useEffect(() => {
      const playCombatIdle = () => {
        if (actions.Combat_idle_loop !== null && combat === true) {
          actions.Combat_idle_loop.play();
  
          if (!combatCooldown) {
            setTimeout(() => {
              playIdle();
              setCombat(false);
            }, 3000);
            setCombatCooldown(true);
          }
        }
      };
  
      mixer.addEventListener('finished', playCombatIdle);
      return () => {
        mixer.removeEventListener('finished', playCombatIdle);
      };
    }, [combat, actions, mixer, combatCooldown]);
  
    // Set texture filters
    useEffect(() => {
      Object.values(materials).forEach((material: THREE.Material) => {
        if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshStandardMaterial) {
          if (material.map) {
            material.map.magFilter = THREE.LinearFilter;
            material.map.minFilter = THREE.LinearMipMapLinearFilter;
            material.map.needsUpdate = true;
          }
        }
      });
    }, [materials]);


  return (
    <>
    {actionFeedback && <div className="feedback">{actionFeedback}</div>}
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="arms_armature">
          <primitive object={nodes.spine002} />
          <primitive object={nodes.ik_handL} />
          <primitive object={nodes.ik_handR} />
        </group>
        <skinnedMesh name="arms" geometry={(nodes.arms as THREE.Mesh).geometry} material={materials['arms.001']} skeleton={(nodes.arms as THREE.SkinnedMesh).skeleton} />
      </group>
    </group>
    </>
  )
}

useGLTF.preload('/black_arms-transformed.glb')
