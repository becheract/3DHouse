/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 phone.glb 
*/

import React ,{ useEffect, useRef,useMemo} from 'react'
import { useGraph, useThree } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from "three";


// Extend the props to include AnimationClip
interface ModelProps extends React.ComponentPropsWithoutRef<"group"> {
  openPhoneModal: () => void; // Add openPhoneModal as an optional function
  closePhoneModal: () => void;
}

export default function Model(props: ModelProps) {
  const { scene, animations } = useGLTF("Phone/phone-transformed.glb");
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { camera } = useThree();
  const phoneRef = useRef<THREE.Group>(null);
  const { actions, mixer } = useAnimations(animations, clone );


  useEffect(() => {
    if(phoneRef.current){
      phoneRef.current.visible = false
    }
  },[])




    useEffect(() => {
      const keyDownListener = (e: KeyboardEvent) => {
        if (e.key === "x" || e.key === "X") {
          if(phoneRef.current !== null) {
            if (actions["closeAction"]) {
              console.log("Starting close animation");
              console.log(Object.keys(actions)); // Logs all available animations
              // Stop all other actions
              mixer.stopAllAction();

              // Play the close animation
              actions["closeAction"]
                .reset() // Reset the animation to the beginning
                .setLoop(THREE.LoopOnce, 1) // Play the animation only once
                .fadeIn(0.5) // Smoothly fade in the animation
                .play(); // Start the animation

                setTimeout(() => {
                  if(phoneRef.current)
                  phoneRef.current.visible = false
                }, 1000)


            }
    
      
          }
           props.closePhoneModal()
        }
      };
  
      document.addEventListener("keydown", keyDownListener);
      return () => {
        document.removeEventListener("keydown", keyDownListener);
      };
    }, [actions, mixer])




  useEffect(() => {
    const keyDownListener = (e: KeyboardEvent) => {
      if (e.key === "g" || e.key === "G" ) {
        if(phoneRef.current !== null){
          phoneRef.current.visible = true
          // Set the phone's position in front of the camera
          // Assuming the camera's forward direction is along the Z axis
          const cameraPosition = camera.position.clone();
          const cameraDirection = camera.getWorldDirection(new THREE.Vector3());
          
          // Offset the phone's position in front of the camera
          // Adjust the distance based on how far in front you want it to appear
          const offset = new THREE.Vector3(0, 0, 0.7);  // 1 unit in front of the camera
          phoneRef.current.position.copy(cameraPosition.add(cameraDirection.multiplyScalar(offset.z)));
          // Adjust the y-axis separately (to move the phone higher or lower)
          const yOffset = -0.50;  // Move the phone 1 unit up on the Y axis
          phoneRef.current.position.y += yOffset;  // Add this offset to the Y position
          // Optionally adjust the orientation of the phone based on camera orientation
          phoneRef.current.rotation.copy(camera.rotation);

          if (actions["openAction"]) {
            mixer.stopAllAction();
            console.log('try')
            console.log(actions["openAction"])
            actions["openAction"]
            .reset()
            .setLoop(THREE.LoopOnce, 1)
            .fadeIn(0.5)
            .play();
            
            setTimeout(() => props.openPhoneModal(), 300)
          }
        }
        
      }

    };

    document.addEventListener("keydown", keyDownListener);
    return () => {
   
      document.removeEventListener("keydown", keyDownListener);
    };
  }, [camera, actions, mixer])



  return (
    <>
    <group  ref={phoneRef} {...props} dispose={null} >
      <group name="Scene" >
        <group name="Armature" position={[0, 0.179, 0]} scale={[0.99, 2.207, 2.207]} rotation={[0,-1.6,0]}>
          <primitive  object={clone} />
          <skinnedMesh name="Cube" geometry={(nodes.Cube as THREE.Mesh).geometry} material={materials['Material.001']} skeleton={(nodes.Cube as THREE.SkinnedMesh).skeleton} />
          <skinnedMesh name="Cube001" geometry={(nodes.Cube001 as THREE.Mesh).geometry} material={materials['Material.001']} skeleton={(nodes.Cube001 as THREE.SkinnedMesh).skeleton} />
        </group>
      </group>
    </group>

      </>
  )
}


useGLTF.preload('/phone.glb')
