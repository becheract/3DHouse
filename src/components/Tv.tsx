/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 tv.glb 
*/

import React, { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import videoURL from "./Gameplay.mp4";
import { vertexShader } from "../../shaders/vertexShader";
import { fragmentShader } from "../../shaders/fragmentShader";

export default function Model(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("TV/tv.glb");

  const videoRef = useRef<THREE.Mesh>(null!);
  const tv_Ref = useRef<THREE.Mesh>(null!);

  useEffect(() => {
    const tvMaterial = materials.TV_06 as THREE.MeshBasicMaterial; // Cast to appropriate type
    const videoElement = document.createElement("video");
    videoElement.src = videoURL; // Replace with your video path or URL
    videoElement.crossOrigin = "anonymous";
    videoElement.loop = true; // Set to true if you want the video to loop
    videoElement.muted = true; // Optional: to mute the video
    videoElement.play(); // Autoplay the video
    const videoTexture = new THREE.VideoTexture(videoElement);
    videoTexture.flipY = false; // Flip the video texture along the Y-axis

    videoTexture.minFilter = THREE.NearestFilter;
    videoTexture.magFilter = THREE.NearestFilter;
    videoTexture.needsUpdate = true;

    const shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        map: { value: tvMaterial.map }, // Pass the video texture to the shader
        uvScale: { value: 4.0 }, // You can adjust this value to scale the UVs
      },
      vertexShader: vertexShader, // Your custom vertex shader
      fragmentShader: fragmentShader, // Your custom fragment shader
    });

    // if (tv_Ref.current) {
    //   tv_Ref.current.material = shaderMaterial;
    // }

    if (videoRef.current) {
      const material = videoRef.current.material;

      // Handle case where material is an array or a single material
      if (Array.isArray(material)) {
        material.forEach((mat: THREE.Material) => {
          if (mat instanceof THREE.MeshBasicMaterial) {
            mat.map = videoTexture;
            mat.needsUpdate = true;
          }
        });
      } else {
        if (material instanceof THREE.MeshBasicMaterial) {
          material.map = videoTexture;
          material.needsUpdate = true;
        }
      }
    }
    // Fix mirroring issue by scaling the mesh negatively on the X-axis
    videoRef.current.scale.x = -1; // Mirror the video along the X-axis

    // Set nearest filter for all materials of the model
    Object.values(materials).forEach((material: THREE.Material) => {
      if (
        material instanceof THREE.MeshBasicMaterial ||
        material instanceof THREE.MeshStandardMaterial
      ) {
        if (material.map) {
          material.map.minFilter = THREE.NearestFilter;
          material.map.magFilter = THREE.NearestFilter;
          material.map.needsUpdate = true;
        }
      }
    });
  }, [materials]);

  return (
    <group {...props} dispose={null}>
      <group position={[-26.634, -1.509, 5.387]}>
        <mesh
          // ref={tv_Ref}
          geometry={(nodes.Cube311 as THREE.Mesh).geometry}
          material={materials.TV_06}
        />
        <mesh
          ref={videoRef}
          geometry={(nodes.Cube311_1 as THREE.Mesh).geometry}
          position={[0.02, 0, 0]}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/tv.glb");
